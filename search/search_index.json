{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Zigbee_home","text":"<p>Note</p> <p>The application is still in early stage and active development, and while it already works and can produce source that will be successfully compiled to a firmware - there are still some missing pieces, features, options and possible breaking changes.</p> <p>Please see navigation menu to the left to start.</p>"},{"location":"install_zigbee_home_cli/","title":"Install zigbee_home CLI","text":"<p>CLI is the main entry point for generating, building and flashing the firmware from one single place.</p> <p>Currently installing from source is available. In later stages compiled binaries will be provided on Github.</p> <p>Go installation is required to build CLI from source. Go version of <code>1.21.4</code> or later is required. One might be already provided in your Linux distribution or <code>brew</code> on Mac.</p>"},{"location":"install_zigbee_home_cli/#installing-using-go-install","title":"Installing using <code>go install</code>","text":"<p>This will be best for users that don't want to mess with source code or have no need to modify internal functionality.</p> <p>To install the CLI just run <pre><code>go install github.com/ffenix113/zigbee_home/cli/cmd/zigbee@develop\n</code></pre> This will install the CLI and it can be later used by running <code>zigbee</code> from command line.</p> <p>Note</p> <p>The name of the executable is quite generic, if this is a problem - please see next runnning method.</p>"},{"location":"install_zigbee_home_cli/#running-from-source-without-installation","title":"Running from source without installation","text":"<p>This solution is for more advanced users, that have some knowledge in git and Go.</p> <p>To run an executable first you would need to pull the source code of the project to some directory: <pre><code>$ git clone git@github.com:ffenix113/zigbee_home.git\n</code></pre> Inside the cloned directory run <pre><code>$ go run ./zigbee_home/cli/cmd/zigbee/... [args...]\n</code></pre></p> <p>This will not add any executables in your PATH. Instead you would need to execute <code>go run</code> command mentioned above each time to run the CLI.</p>"},{"location":"install_zigbee_home_cli/#updating-the-source-code","title":"Updating the source code","text":"<p>When using this method the code will not be updated automatically in any way. To do this you would need to navigate to cloned repository and run <pre><code>$ git pull\n</code></pre></p>"},{"location":"supported_boards/","title":"Supported boards","text":""},{"location":"supported_boards/#plans-for-supporting-boards","title":"Plans for supporting boards","text":"<p>The plan for board support is to have as much nrf52840-based boards to make compatible as possible.</p> <p>This probably can be achieved by utilizing MCUboot, to make the bootloader the same on all boards. It will also bring possible benefits like serial flashing, DFU through BLE and OTA for Zigbee.</p>"},{"location":"supported_boards/#what-is-the-problem-why-mcuboot","title":"What is the problem? Why MCUboot?","text":"<p>As of now different boards can come with a couple of bootloaders, each one of them may require different approach for flashing and different set of configuration options. Supporting each possible configuration may not be easy, nor needed.</p> <p>With MCUboot the interface between boards and zigbee_home should be the same, independednt of the board.</p>"},{"location":"supported_boards/#mcuboot-support","title":"MCUboot support","text":"<p>There is on-going work to investigate configuration and usage of MCUboot as second-stage bootloader for nRF52840 Dongle(as it is shipped with nRF5 Bootloader), which should lead a way to support on other boards. For example support for another board is work-in-progress based on MCUboot: Arduino nano 33 BLE. </p>"},{"location":"supported_boards/#if-not-mcuboot-as-second-stage-bootloader","title":"If not MCUboot as second-stage bootloader?","text":"<p>If MCUboot would not be enough to make boards work correctly and support necessary functionality - then another solution could be to flash it directly via JTag/SWD, in hopes that this will make it work.</p>"},{"location":"supported_boards/#currently-supported-boards","title":"Currently supported boards","text":"<p>This list can be better thought of as \"supported bootloaders\" instead of the boards.</p> <ul> <li>nRF52840 Dongle (<code>nrf52840dongle_nrf52840</code>) - Uses <code>nrf52_legacy</code> bootloader.</li> <li>Arduino Nano 33 BLE (Sense) (<code>arduino_nano_33_ble</code>) - Uses <code>arduino</code> bootloader. With this configuration other boards with nrf52840 and Bossac bootloader(== Arduino bootloader) might be supported. Give it a try!</li> </ul>"},{"location":"supported_boards/#experimental","title":"Experimental","text":"<ul> <li> Any Adafruit bootloader-based boards. This includes support for bootloaders with SD S132, S140 v6 and v7. A <code>bootloader</code> configuration option must be set to a necessary bootloader. Supported bootloader versions are <ul> <li><code>adafruit_nrf52_sd132</code></li> <li><code>adafruit_nrf52_sd140_v6</code></li> <li><code>adafruit_nrf52_sd140_v7</code></li> </ul> </li> </ul>"},{"location":"sensors/supported_sensors/","title":"Supported sensors","text":""},{"location":"sensors/supported_sensors/#supporting-more-sensors","title":"Supporting more sensors","text":"<p>Depending on a sensor it might be either easy, or rather involving to provide support for a sensor.</p> <p>Currently there is a work to change how sensors are polled to make all sensors to work through Zephyr's Sensor API, which would result in same codebase for all sensors in the main app, while drivers will implement interface required to talk to the sensors.</p> <p>When this change will be done - all sensors officially supported by Zephyr, will be supported. Note that the sensor will be supported only in the context of Zigbee Cluster Library, meaning that if sensor supports some measurements that Zigbee Cluster Library does not support - it will not be available in Zigbee.</p>"},{"location":"sensors/supported_sensors/#supported-sensors","title":"Supported sensors","text":"<p>Note</p> <p>Full per-sensor options will be defined later. For now please refer to configuration file documentation or latest configuration in repository for sensor configuration options.</p> <ul> <li><code>bme280</code> &amp; <code>bme680</code> - Bosch BME280 / BME680</li> <li><code>scd4x</code> - Sensirion SCD41 (driver by nobodyguy)</li> </ul>"},{"location":"sensors/supporting_new_sensors/","title":"Supporting new sensors","text":"<p>Supporting new sensors can be really easy, or somewhat hard, depending on if the sensor has drivers in Zephyr and if all necessary Zigbee clusters are defined.</p>"},{"location":"sensors/supporting_new_sensors/#sensor-base","title":"Sensor base","text":"<p>All sensors must implement an interface <code>sensor.Sensor</code> defined in <code>types/sensor</code> package: <pre><code>type Sensor interface {\n    // Stringer is for human-readable name\n    fmt.Stringer\n    // Label returns unique label value for the sensor.\n    // Generally this method should not be defined by user,\n    // intstead it will be defined in embedded `*base.Base`\n    Label() string\n    Template() string\n    cluster.Provider\n    appconfig.Provider\n    devicetree.Applier\n}\n</code></pre></p> <p>Each sensor must embed <code>*base.Base</code>, which is defined in <code>/sensor/base</code>, which provides all of the methods above as no-ops: <pre><code>type SomeSensor struct {\n    *base.Base `yaml:\",inline\"` // The tag is required as well\n}\n</code></pre></p> <p>Sensor can define</p> <ul> <li>Zigbee clusters - necessary for any sensor that should output values to coordinator, be controlled by coordinator, or both.</li> <li>Devicetree overlay configuration - should be necessary by all sensors, as devicetree defines how sensor is attached to the board.</li> <li>Configuration options - generally also would be required, as Zephyr may choose to include driver for the sensor based on this configuration.</li> <li>Template - if sensor is supported by Zephyr and all Zigbee clusters are defined - this should be optional, as known sensors will re-use common functionality.</li> <li>Extenders - if sensor requires additional functionality like adding required headers, or adding a driver via Zephyr module - this can be defined here.</li> </ul>"},{"location":"sensors/supporting_new_sensors/#user-configurable-and-internal-sensor-options","title":"User-configurable and internal sensor options","text":"<p>Some sensors might need some user configuration to be working properly.</p> <p>For example internal device temperature sensor does not need user configuration, as it will be defined the same for any board and peripherals configuration.</p> <p>Others might need some input to input address of I2C sensor, set operating mode or disabling part of the sensor.</p> <p>In some cases configuration options may also be used for internal purposes, like diferentiating between variants of the sensor. For this user should not be able to provide this configuration manually or change it in any way.</p> <p>Yaml tag is used to tell if option is user-configurable or not. <code>yaml:\"-\"</code> would mean internal option, while omitting the tag, or specifying a field name like <code>yaml:\"sample_rate\"</code> would make it user-configurable.</p> <p>This can be done by adding necessary configuration fields to sensor struct: <pre><code>type SomeSensor struct {\n    *base.Base `yaml:\",inline\"`\n    // All of fields below will be a part of sensor configuration.\n\n    // This fields are internal, \n    // meaning that they will not be user-configurable.\n    // Tag `yaml:\"-\"` means that this options will \n    // not be picked up from configuration file.\n    Variant string `yaml:\"-\"`\n    Frequency uint `yaml:\"-\"`\n\n    // This options are user-configurable.\n    // In configuration file they can be added by\n    // lowercasing field name, or providing a name\n    // as defined in `yaml` tag(if any).\n    // Note that any Yaml unmarshalable type is supported.\n    I2C base.I2CConnection // This will be `i2c` in configuration file\n    OperationMode string // This will be `operationmode`\n    SampleRate uint `yaml:\"sample_rate\"` // This will be `sample_rate`\n}\n</code></pre></p>"},{"location":"sensors/supporting_new_sensors/#adding-sensor-definition","title":"Adding sensor definition","text":"<p>All sensors have to be defined and added to a known sensor list.</p> <p>Sensor definition provides a necessary information on how to add the sensor to the firmware. For example configuration options that should be added.</p> <p>Sensor definition should be added to <pre><code>/sensor/&lt;manufacturer&gt;/&lt;sensor_name&gt;.go\n</code></pre> And a known sensor entry should be added to <pre><code>/types/sensor/known.go\n</code></pre></p>"},{"location":"sensors/supporting_new_sensors/#adding-new-zigbee-cluster","title":"Adding new Zigbee cluster","text":"<p>TBD</p>"},{"location":"sensors/supporting_new_sensors/#sensor-supported-by-zephyr","title":"Sensor supported by Zephyr","text":"<p>This is the easiest case, as only sensor definition is required, without any template files or custom drivers.</p>"},{"location":"sensors/supporting_new_sensors/#example-bosch-bme280","title":"Example: Bosch BME280","text":"<pre><code>package bosch\n\nimport (\n    \"strings\"\n\n    \"github.com/ffenix113/zigbee_home/cli/sensor/base\"\n    \"github.com/ffenix113/zigbee_home/cli/templates/extenders\"\n    \"github.com/ffenix113/zigbee_home/cli/types/appconfig\"\n    dt \"github.com/ffenix113/zigbee_home/cli/types/devicetree\"\n    \"github.com/ffenix113/zigbee_home/cli/types/generator\"\n    \"github.com/ffenix113/zigbee_home/cli/zcl/cluster\"\n)\n\ntype BME280 struct {\n    // Required embedding of `*base.Base`\n    *base.Base `yaml:\",inline\"`\n    // This sensor works through I2C, \n    // so get the configuration for it\n    I2C        base.I2CConnection\n    // Variant is \"internal\" option, \n    // that defines if 280 or 680 is actually used\n    Variant    string `yaml:\"-\"`\n}\n\nfunc NewBME280() *BME280 {\n    return &amp;BME280{\n        Variant: \"bme280\",\n    }\n}\n\nfunc (b BME280) String() string {\n    return \"Bosch \" + strings.ToUpper(b.Variant)\n}\n\nfunc (BME280) Clusters() cluster.Clusters {\n    // Cluster values below are taken from sensor datasheet.\n    return []cluster.Cluster{\n        cluster.Temperature{\n            MinMeasuredValue: -40,\n            MaxMeasuredValue: 85,\n            Tolerance:        1,\n        },\n        cluster.Pressure{\n            MinMeasuredValue: 30,\n            MaxMeasuredValue: 110,\n            Tolerance:        0,\n        },\n        cluster.RelativeHumidity{\n            MinMeasuredValue: 10,\n            MaxMeasuredValue: 90,\n        },\n    }\n}\n\nfunc (b BME280) AppConfig() []appconfig.ConfigValue {\n    return []appconfig.ConfigValue{\n        appconfig.CONFIG_I2C.Required(appconfig.Yes),\n        // Yes, for both 280 &amp; 680 we are setting through BME280\n        appconfig.CONFIG_BME280.Required(appconfig.Yes),\n        appconfig.NewValue(\"CONFIG_BME280_MODE_FORCED\").Required(appconfig.Yes),\n    }\n}\n\nfunc (b BME280) ApplyOverlay(tree *dt.DeviceTree) error {\n    i2cNode := tree.FindSpecificNode(dt.SearchByLabel(b.I2C.ID))\n    if i2cNode == nil {\n        return dt.ErrNodeNotFound(b.I2C.ID)\n    }\n\n    i2cNode.AddNodes(&amp;dt.Node{\n        Name:        b.Variant,\n        Label:       b.Label(),\n        UnitAddress: b.I2C.UnitAddress(),\n        Properties: []dt.Property{\n            dt.NewProperty(dt.PropertyNameCompatible, dt.FromValue(\"bosch,\"+b.Variant)),\n            dt.NewProperty(\"reg\", dt.Angled(b.I2C.Reg())),\n            dt.PropertyStatusEnable,\n        },\n    })\n\n    return nil\n}\n\n// For now this Extenders is required for sensors,\n// as it includes necessary configuration for Zephyr \n// to add sensor drivers and functions.\nfunc (BME280) Extenders() []generator.Extender {\n    return []generator.Extender{\n        extenders.NewSensor(),\n    }\n}\n</code></pre>"},{"location":"sensors/supporting_new_sensors/#sensor-that-are-not-supported-by-zephyr","title":"Sensor that are not supported by Zephyr","text":""},{"location":"sensors/supporting_new_sensors/#sensor-without-need-for-driver","title":"Sensor without need for driver","text":"<p>TBD</p>"},{"location":"sensors/supporting_new_sensors/#external-driver-as-module","title":"External driver as module","text":"<p>TBD</p>"},{"location":"using_the_cli/","title":"Using the CLI","text":"<p>Zigbee_home CLI provides a way to do necessary actions to produce a device that is flashed with firmware generated &amp; built with this project.</p> <p>There are 3 things that CLI is responsible for: * Generating the source code * Building the firmware * Flashing built firmware</p> <p>Other functionalities might be available in the future.</p>"},{"location":"using_the_cli/#cli-commands","title":"CLI commands","text":""},{"location":"using_the_cli/#global-flags","title":"Global flags","text":"<p>At top level there is only option to provide path for configuration file, if it is not located in working directory. <pre><code>--config &lt;path_to_file&gt;\n</code></pre></p> <p>For example</p> <pre><code>$ go run ./cmd/zigbee/... --config ../zigbee.yml\n$ # Or if used with installed CLI\n$ zigbee --config ../zigbee.yml\n</code></pre>"},{"location":"using_the_cli/#firmware","title":"<code>firmware</code>","text":"<p>This is a base command for sub-commands, and so it is not useful on it's own. <pre><code>zigbee firmware\n</code></pre></p>"},{"location":"using_the_cli/#flags","title":"Flags","text":"<code>--workdir</code> <p>Provide an optional working directory. This is where source code will be generated and used from.</p> <p>Defaults to current working directory.</p>"},{"location":"using_the_cli/#generate-source-code","title":"Generate source code","text":"<p>Currently, generation of source code is not a separate action, as it is a part of building the firmware. A project goal is to do single call to do all the necessary actions, where user provides a configuration file and after running the CLI - a device will be flashed with generated firmware.</p> <p>To generate source code from configuration file user must call  <pre><code>firmware build --only-generate\n</code></pre></p> <p>For example <pre><code>$ zigbee --config ../zigbee.yml firmware build --only-generate\n</code></pre></p>"},{"location":"using_the_cli/#build-the-firmware","title":"Build the firmware","text":"<p>Warning</p> <p>Currently each time the build is requested - CLI will re-generate the source code. This means that any manual changes to the generated source code would be removed.</p> <p>Note</p> <p>As building firmware requires having environment set correctly it is not possible to simply run this command from normal shell environment. If necessary this command can be executed from terminal that nRF Connect VS Code extension can create by going to <code>nRF Connect</code> extension -&gt; in <code>Applications</code> right click necessary build configuration and select <code>Start new terminal here</code>. This will open a new terminal window with correct environment, in which this command can be executed.</p> <p>To generate and build the firmware use <pre><code>firmware build\n</code></pre></p> <p>This command does not need to be executed inside the generate source directory. Instead <code>--workdir</code> flag can be provided to point to necessary directory with source code.</p> <p>For example <pre><code>$ go run ./cmd/zigbee/... firmware --workdir ~/firmware/soil_moisture_sensor build\n</code></pre></p>"},{"location":"using_the_cli/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>To flash the firmware user needs to set board to bootloader mode and then run <pre><code>firmware flash\n</code></pre> For example <pre><code>$ zigbee firmware --workdir ~/firmware/soil_moisture_sensor flash\n</code></pre></p>"},{"location":"using_the_cli/#full-example","title":"Full example","text":"<p>This is a full example of what a typical flow for creating a configuration, generating &amp; building source code and then flashing the device.</p> <p>Example makes some assumptions:</p> <ul> <li>Board is nRF52840 Dongle with stock bootloader</li> <li>Generated source code will be located in <code>./firmware</code></li> </ul> <pre><code>$ cat zigbee.yml\ngeneral:\n  runevery: 2m\n  board: nrf52840dongle_nrf52840\n  flasher: nrfutil\n  flasheroptions:\n    port: /dev/ttyACM1\nboard:\n  i2c:\n    - id: i2c0\n      port: 0\n      sda: 29\n      scl: 31\nsensors:\n  - type: scd4x\n    i2c:\n      id: i2c0\n$ ls\nzigbee.yml\n$ zigbee firmware --workdir ./firmware build --only-generate\n$ # Now user goes to VS Code, opens the ./firmware directory and compiles the source code\n$ # See 'Building the firmware' page for instructions on how to do it.\n$ # As a verification that the firmware was built correctly execute following command:\n$ ls ./firmware/build/zephyr/zephyr.hex\nzephyr.hex\n$ # User starts bootloader mode on the board by clicking reset button twice\n$ zigbee firmware --workdir ./firmware flash\n</code></pre>"},{"location":"using_the_cli/building_the_firmware/","title":"Building the firmware","text":"<p>Note</p> <p>The project is still in development, and the steps to build and flash the firmware will change in the future.</p>"},{"location":"using_the_cli/building_the_firmware/#building","title":"Building","text":"<p>For now zigbee_home CLI cannot build the application directly, unless run in a configured nRF Connect &amp; Zephyr environment.</p> <p>As such while this is the case - we will rely on the VS Code with nRF Connect extension to build the firmware.</p>"},{"location":"using_the_cli/building_the_firmware/#preparing-environment","title":"Preparing environment","text":"<p>Nordic provides an installation tutorial video for setting up the environment for VS Code.</p> <p>This preparation is only needed once, and after all the tools are set up - you don't need to do it again.</p>"},{"location":"using_the_cli/building_the_firmware/#build-from-extension","title":"Build from extension","text":"<p>To build the firmware just open the generated firmware source file directory in VS Code. Then press the nRF Connect extension in the sidebard and choose <code>Create new build configuration</code>:</p> <p></p> <p>This will open a new tab with some options. The only thing that needs to be changed is to provide proper board name.</p> <p>Currently, the only supported board is <code>nrf52840dongle_nrf52840</code>. More commonly known as nRF52840 Dongle</p> <p></p> <p>After this you can press \"Build configuration\" and wait for the build to finish.</p> <p>Note</p> <p>While building there may be some warnings, but not errors. If there is an error while building the source it is most probably that there is some mis-configuration in <code>zigbee.yml</code>, or other provided configuration while generating source from CLI.</p>"},{"location":"using_the_cli/building_the_firmware/#building-firmware-again","title":"Building firmware again","text":"<p>After first build it is not necessary to create new build configuration again.</p> <p>Instead open the nRF Connect extension, choose already existing configuration by clicking on it and click <code>Build</code> in <code>Actions</code> tab:</p> <p></p>"},{"location":"using_the_cli/building_the_firmware/#build-with-zigbee_home-cli","title":"Build with zigbee_home CLI","text":"<p>TBD</p>"},{"location":"using_the_cli/configuration_file/","title":"Configuration file","text":"<p>CLI relies heavily on the configuration file to do most actions.</p> <p>For example the configuration file will provide information such as:</p> <ul> <li>Flashing configuration</li> <li>Whether the device should be router or not</li> <li>What peripherals are available on the board</li> <li>How frequently to poll the sensors</li> <li>What sensors are attached</li> </ul> <p>By default, configuration file is called <code>zigbee.yml</code> and CLI will try to find it in the working directory.  It is possible to point the CLI to this configuration file by providing a flag. For this see Using the CLI</p>"},{"location":"using_the_cli/configuration_file/#example-configuration","title":"Example configuration","text":"<p>Note</p> <p>The complete and latest file is located in the repository, in <code>cli/zigbee.yml</code>. It may contain newer/changed configuration options.</p> <pre><code># Format for this file is not stable, and can change at any time.\n\ngeneral:\n  # Defines how much time a loop will sleep after each iteration.\n  # Note: This does not necesseraly mean that each 2 minutes\n  # sensor values will be updated. Currently all sensors are polled\n  # synchronously, which means that if there are 3 sensors defined\n  # and each needs 5 seconds to obtain the result then it will take\n  # (3 * 5)s + runevery, which in this case will be 1m15s.\n  runevery: 1m\n  # Board name, as defined in Zephyr.\n  board: nrf52840dongle_nrf52840\n\n  # This paths are necessary to build the generated firmware.\n  # If nRF Connect setup was done with VS Code extension -\n  # most probably this can be left empty, but if version changes -\n  # new path would need to be set here.\n  # Paths specified here can start with `~/`, and contain\n  # environmental variables, which will be resolved.\n  # This values have sane defaults and point to ~/ncs/...\n  # Env variables NCS_TOOLCHAIN_BASE &amp; ZEPHYR_BASE have\n  # priority over this fields.\n  #ncs_toolchain_base: ~/toolchains/7795df4459/\n  #zephyr_base: ~/ncs/zephyr\n\n  # zigbee_channels will provide optional list of channels to use.\n  # Note: if not defined device will use all available channels,\n  # so it is not needed to define this if not specifically necessary.\n  zigbee_channels: [11,13,15,16,17]\n\n  # Flasher tells which flashing method to use.\n  # Currently `nrfutil`, `mcuboot` and `west`\n  # are defined(but not equally tested). Nrfutil works though.\n  flasher: nrfutil\n  # Flasheroptions are flasher-specific options.\n  flasheroptions:\n    port: /dev/ttyACM1\n\n# This section is for defining peripherals\n# on the board. I.e. uart, spi, i2c, etc.\n# NOTE: Only changes should be defined here.\n# See https://github.com/zephyrproject-rtos/zephyr/tree/main/boards/&lt;arch&gt;/&lt;board_name&gt;/&lt;board_name&gt;.dts\n# for existing definitions for the board.\n# For example nRF52840 Dongle would have board devicetree at\n# https://github.com/zephyrproject-rtos/zephyr/tree/main/boards/arm/nrf52840dongle_nrf52840/nrf52840dongle_nrf52840.dts\nboard:\n  # Specifically define bootloader for the board.\n  # This field is optional, and in most cases this might not be needed.\n  # But it is possible that board can be flashed\n  # with some non-default bootloader, or that the generated firmware is not\n  # placed correctly in memory. This setting can help in above situations.\n  # Also this option can be used to try and support boards that\n  # are not labeled as officialy supported.\n  # \n  # Note: if this field is present - this will force bootloader\n  # to be selected one, even if the value is empty string.\n  #bootloader: nrf52_legacy\n\n  # This option will add UART loging functionality.\n  # User can choose which console to use(usb or uart).\n  # UART has to be defined either in default device tree,\n  # or in `board.uart` section.\n  # Quite limited for now, but can be easily extended\n  debug:\n    # Enable logging and possibly LEDs\n    # for debugging.\n    enabled: false\n    # Console is where logs will be spit out.\n    # Choices are:\n    #  * usb - no need to define any other configuration for `usb`.\n    #  * uart1, uart2, ... - this either should be already defined for used board,\n    #                        or be defined in `uart` section.\n    console: uart0\n    # LEDs will use LED to show some board state(i.e. power, connection, etc).\n    # Leds used here MUST be always defined in `leds`, even if they already\n    # present in board definition.\n    leds:\n      # If false - leds will not be enabled to signal state.\n      enabled: true\n      # Define led which will be used to show that the board is powered.\n      power: led_green\n  # Change device type from sleepy end device to router.\n  # This allows for device to always be available from coordinator\n  # and other devices.\n  # By default device will be configured as sleepy end device.\n  # Note: Enabling router will increase the size of the firmware.\n  is_router: false\n  # I2C is optional, only to provide different pins for i2c instance(s)\n  i2c:\n      # ID of instance is the same as defined in the SoC definition.\n      # Generally they are in form of `i2c[0-9]`.\n      # Number of i2c instances is also limited, and this allows only to\n      # re-define pins for specified i2c instance.\n    - id: i2c0\n      sda: 0.29\n      scl:\n        port: 0\n        pin: 31\n  uart:\n    - id: uart0\n      # Pins are optional, if this is existing uart interface. \n      tx: 1.03\n      rx: 1.10\n  leds:\n    - id: led_green\n      # The `pin` section is optional, if led is already present in board definition.\n      pin:\n        port: 0\n        pin: 6\n        inverted: true\n\n# Sensors define a list of devices that \n# can provide sensor values or be controlled\nsensors:\n  # All sensors have type, and most will \n  # also have sensor-specific configuration.\n  - type: bme680\n    i2c:\n      id: i2c0\n      # Some devices might have changable I2C address, \n      # which can be defined here.\n      # Note: this does not change the device address,\n      # only tells which address to use.\n      addr: '0x76'\n  - type: scd4x\n    i2c:\n      id: i2c0\n  # - type: device_temperature\n  # on_off is a sensor that will respond to on/off state of the pin.\n  # For now verifyied to be controlled by the client only,\n  # so not by actually changing the state of the pin manually.\n  # - type: on_off\n  #   pin:\n  #     # This is Green LED(LD1) on nrf52840 Dongle\n  #     port: 0\n  #     pin: 6\n  #     inverted: true\n</code></pre>"},{"location":"using_the_cli/configuration_file/#sensor-options","title":"Sensor options","text":"<p>Each sensor can have unique configuration options. To define such options they must be provided in their configuration in <code>sensors</code> section of the configuration file.</p> <p>If sensors do not provide required configuration - the generated source code might not compile with some errors, or sensor might not report values correctly.</p> <p>Some sensors would not require any configuration: <pre><code>sensors:\n  - type: device_temperature\n</code></pre> , while others might need some: <pre><code>sensors:\n  - type: bme680\n    i2c:\n      id: i2c0\n      addr: '0x76'\n</code></pre> Here we define that the board will have a Bosch BME680 sensor attached to I2C instance with id <code>i2c0</code>, and will have address <code>0x76</code>.</p> <p>Other options may also be specified in the future, for example: <pre><code>sensors:\n  - type: bme680\n    temperature:\n      oversampling: x4 # Notice the `oversampling` option\n    i2c:\n      id: i2c0\n      addr: '0x76'\n</code></pre></p>"},{"location":"using_the_cli/flash_firmware/","title":"Flash firmware","text":"<p>TBD. Please see Using the CLI and full example for flashing instructions.</p>"},{"location":"using_the_cli/generating_source_code/","title":"Generating source code","text":"<p>TBD. Please see Using the CLI and full example for generation instructions.</p>"}]}